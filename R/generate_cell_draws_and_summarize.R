#' Generate cell draws and summary rasters from INLA model
#' 
#' @description Use INLA posteriors to predict out across a grid
#' 
#' @details
#' Based on a fitted INLA model, the survey area defined in an ID raster, and a set of
#' covariates, generate predictive grid cell draws and summary rasters across a study area.
#' 
#' @param inla_model Output from [fit_inla_model()]
#' @param inla_mesh An SPDE mesh used to define the spatial integration points of the INLA
#'   geostatistical model. Typically created using [INLA::inla.mesh.2d()] or a similar
#'   function.
#' @param n_samples (numeric) Number of posterior predictive samples to draw.
#' @param id_raster (terra SpatRaster) raster showing all cell locations where predictions
#'   should be taken.
#' @param covariates (list) Named list of all covariate effects included in the model,
#'   typically generated by [load_covariates()].
#' @param inverse_link_function (character) If a link function was used in the INLA model,
#'   name of the R function to transform the predictive draws from link space to natural
#'   space. For example, in a logit-linked binomial model, pass 'plogis' (as a string is 
#'   fine) to invert-logit the predictive draws.
#' @param nugget_in_predict (`logical(1)`, default TRUE) Should the nugget term be used as
#'   an IID noise term applied to each pixel-draw?
#' @param ui_width (numeric, default 0.95) Size of the uncertainty interval width when
#'   calculating the upper and lower summary rasters
#' 
#' @return Named list containing at least the following items:
#'   - "parameter_draws": posterior samples generated from [INLA::inla.posterior.sample()]
#'   - "cell_draws": A matrix of grid cell draws. Each row represents a non-NA pixel in
#'     the `id_raster`, in the same order that would be pulled by [terra::values()], and
#'     each column represents a different posterior draw.
#'   - "cell_pred_mean": Mean predictive estimate by grid cell, formatted as a terra
#'     SpatRaster
#'   - "cell_pred_lower": Lower bound of (X%) uncertainty interval, formatted as a terra
#'     SpatRaster
#'   - "cell_pred_upper": Upper bound of (X%) uncertainty interval, formatted as a terra
#'     SpatRaster
#' 
#' @import data.table
#' @importFrom assertthat assert_that
#' @importFrom INLA inla.posterior.sample inla.spde.make.A
#' @importFrom Matrix rowMeans
#' @importFrom matrixStats rowQuantiles
#' @importFrom purrr map map_dbl
#' @importFrom terra extract values
#' @importFrom tictoc tic toc
#' @export
generate_cell_draws_and_summarize <- function(
  inla_model, inla_mesh, n_samples, id_raster, covariates, inverse_link_function,
  nugget_in_predict = TRUE, ui_width = 0.95
){
  tictoc::tic("Posterior cell draw generation")

  # Generate INLA posterior samples
  posterior_samples <- INLA::inla.posterior.sample(
    n = n_samples, result = inla_model, add.names = FALSE
  )
  # Reorder as a matrix with rows named after the coresponding model terms
  latent_matrix <- purrr::map(posterior_samples, 'latent') |> do.call(what = cbind)
  rownames(latent_matrix) <- rownames(posterior_samples[[1]]$latent) |>
    strsplit(split = ':') |>
    vapply(`[`, 1, FUN.VALUE = character(1))
  
  ## Generate data objects needed to project from the posterior draws to prediction points
  # A) Table containing all fixed effects
  id_raster_table <- data.table::as.data.table(id_raster, xy = T) |> na.omit()
  cov_names <- names(covariates)
  for(cov_name in cov_names){
    id_raster_table[[cov_name]] <- terra::extract(
      x = covariates[[cov_name]],
      y = as.matrix(id_raster_table[, .(x, y)])
    )[, 1]
  }
  # B) Projection matrix: mesh to all prediction locations
  A_proj_predictions <- INLA::inla.spde.make.A(
    mesh = inla_mesh,
    loc = as.matrix(id_raster_table[, .(x, y)])
  )

  ## Split parameter matrix into fixed effect coeffients and spatial mesh effects
  # Fixed effect coefficients
  fe_rows <- which(rownames(latent_matrix) == 'covariates')
  fe_coefficients <- latent_matrix[fe_rows, ]
  # Spatial mesh effects
  spatial_mesh_effects <- latent_matrix[rownames(latent_matrix) == 'space', ]
  assertthat::assert_that(nrow(spatial_mesh_effects) == ncol(A_proj_predictions))

  # Project to all grid locations
  fe_draws <- as.matrix(id_raster_table[, ..cov_names]) %*% fe_coefficients
  re_draws <- as.matrix(A_proj_predictions %*% spatial_mesh_effects)
  assertthat::assert_that(all.equal(dim(fe_draws), dim(re_draws)))

  # Optionally add nugget effect
  if(nugget_in_predict){
    # Get draws of nugget precision -> draws of nugget standard deviation
    nugget_precision <- purrr::map(posterior_samples, 'hyperpar') |>
      purrr::map_dbl("Precision for nugget")
    nugget_sigma <- 1 / sqrt(nugget_precision)
    # Generate IID noise for each draw
    nugget_draws <- rnorm(length(fe_draws), mean = 0, sd = nugget_sigma) |>
      matrix(ncol = n_samples, byrow = TRUE)
  } else {
    nugget_draws <- 0
  }
  
  # Combine and apply the inverse link function to get predictive draws by grid cell
  predictive_draws <- get(inverse_link_function)(fe_draws + re_draws + nugget_draws)

  ## Summarize as rasters
  to_fill <- which(!is.na(terra::values(id_raster)))
  r_mean <- r_lower <- r_upper <- id_raster
  terra::values(r_mean)[to_fill] <- Matrix::rowMeans(predictive_draws)
  terra::values(r_lower)[to_fill] <- (
    matrixStats::rowQuantiles(predictive_draws, probs = (1 - ui_width)/2)
  )
  terra::values(r_upper)[to_fill] <- (
    matrixStats::rowQuantiles(predictive_draws, probs = 1 - (1 - ui_width)/2)
  )

  # Stop timer
  tictoc::toc()

  # Return list of predictions
  predictions_list <- list(
    parameter_draws = posterior_samples,
    cell_draws = predictive_draws,
    cell_pred_mean = r_mean,
    cell_pred_lower = r_lower,
    cell_pred_upper = r_upper
  )
  return(predictions_list)
}
