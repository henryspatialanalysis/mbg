## #######################################################################################
##
## RUN REGRESSION SUB-MODELS 
##
## PURPOSE: Run regression models using the `caret` package for use in stacking
##
## #######################################################################################

#' Run regression sub-models
#' 
#' @description Wrapper to run many regression sub-models using the caret package
#' 
#' @param input_data A data.frame with at least the following columns:
#'   - 'indicator': number of "hits' per site, e.g. tested positive for malaria
#'   - 'samplesize': total population sampled at the site
#'   - 'x': x position, often longitude
#'   - 'y': y position, often latitude
#' @param id_raster terra SpatRaster with non-NA pixels delineating the extent of the
#'   study area 
#' @param covariates (list) Named list of all covariate effects included in the model,
#'   typically generated by [load_covariates()].
#' @param cv_settings Named list of cross-validation settings, passed to
#'   [caret::trainControl].
#' @param model_settings Named list where the name of each header corresponds to a model
#'   run in [caret::train], and the arguments correspond to the model-specific settings
#'   for that model type.
#' 
#' @return List with two items:
#'   - "models": A list containing summary objects for each regression model
#'   - "predictions": Model predictions covering the entire id_raster
#'
#' @importFrom caret trainControl train
#' @importFrom terra extract values
#' @import data.table
#' @export 
run_regression_submodels <- function(
  input_data, id_raster, covariates, cv_settings, model_settings
){
  # Prepare training data and eventual prediction space
  id_raster_table <- data.table::as.data.table(id_raster, xy = TRUE) |> na.omit()
  colnames(id_raster_table)[3] <- 'pixel_id'
  cov_names <- names(covariates)
  for(cov_name in setdiff(cov_names, 'intercept')){
    input_data[[cov_name]] <- terra::extract(
      x = covariates[[cov_name]],
      y = as.matrix(input_data[, .(x, y)])
    )[, 1]
    id_raster_table[[cov_name]] <- terra::extract(
      x = covariates[[cov_name]],
      y = as.matrix(id_raster_table[, .(x, y)])
    )[, 1]    
  }

  # Subset only to data outcome (indicator / samplesize), covariates, and x/y
  cov_cols <- c(setdiff(cov_names, 'intercept'), 'x', 'y')
  input_data$data_rate <- input_data$indicator / input_data$samplesize
  training_data <- copy(input_data[, c('data_rate', cov_cols), with = F ])
  prediction_grid <- copy(na.omit(id_raster_table))

  # Set internal out-of-sample tuning
  oos_tune <- do.call(caret::trainControl, args = cv_settings)

  # Make a fully NA raster to add predictions to
  template_raster <- id_raster
  terra::values(template_raster) <- NA_real_

  # Run each stacker, then predict to a raster
  model_names <- names(model_settings)
  models_list <- preds_list <- vector('list', length = length(model_names))
  names(models_list) <- names(preds_list) <- model_names
  for(model_name in model_names){
    # Fit caret model
    model_args <- c(
      list(data_rate ~ ., data = training_data, method = model_name, trControl = oos_tune),
      model_settings[[model_name]]
    )
    models_list[[model_name]] <- do.call(caret::train, args = model_args)
    # Predict out to raster
    prediction_grid$new_vals <- predict(
      models_list[[model_name]],
      newdata = prediction_grid
    )
    pred_raster <- template_raster
    terra::values(pred_raster)[prediction_grid$pixel_id] <- prediction_grid$new_vals
    preds_list[[model_name]] <- pred_raster
  }
  return(list(models = models_list, predictions = preds_list))
}
