#' Prepare data stack for INLA
#'
#' @details Creates the formatted input data to be used by the INLA model. For more
#'   information about penalized complexity priors, see Daniel Simpson's
#'   \href{https://doi.org/10.1214/16-STS576}{paper} on the subject.
#' 
#' @seealso [mbg::fit_inla_model()]
#'  
#' @param input_data A data.frame with at least the following columns:
#'   - 'indicator': number of "hits' per site, e.g. tested positive for malaria
#'   - 'samplesize': total population sampled at the site
#'   - 'x': x position, often longitude
#'   - 'y': y position, often latitude
#' @param id_raster terra SpatRaster with non-NA pixels delineating the extent of the
#'   study area 
#' @param covariates (list) Named list of all covariate effects included in the model,
#'   typically generated by [load_covariates()].
#' @param spde_range_pc_prior (list) A named list specifying the penalized complexity
#'   prior for the SPDE range. The two named items are "threshold", the test threshold
#'   (set as a proportion of the overall mesh extent), and "prob_below", the prior
#'   probability that the value is BELOW that range threshold. The function automatically
#'   converts "threshold" from a proportion of the overall mesh extent into a distance.
#' @param spde_sigma_pc_prior (list) A named list specifying the penalized complexity 
#'   prior for sigma (standard deviation) of the SPDE object. The two named items are
#'   "threshold", the test threshold for the standard deviation, and "prob_above",
#'   the prior probability that sigma will EXCEED that threshold.
#' @param sum_to_one (logical, default FALSE) Should the input covariates be constrained
#'   to sum to one? Usually FALSE when raw covariates are passed to the model, and TRUE
#'   if running an ensemble ('stacking') model.
#' 
#' @return List containing the following items:
#'   - "mesh": The mesh used to approximate the latent Gaussian process
#'   - "spde": The SPDE object that will be used to fit the INLA model
#'   - "inla_data_stack": The data stack to be passed to `INLA::inla()`
#'   - "formula_string": The formula specification to be passed to `INLA::inla()`
#' 
#' @importFrom INLA inla.mesh.2d inla.spde2.pcmatern inla.spde.make.A inla.stack
#' @importFrom data.table as.data.table
#' @importFrom terra extract
#' @export
prepare_inla_data_stack <- function(
  input_data, id_raster, covariates,
  spde_range_pc_prior = list(threshold = 0.1, prob_below = 0.05),
  spde_sigma_pc_prior = list(threshold = 3, prob_above = 0.05),
  sum_to_one = FALSE
){
  id_raster_table <- data.table::as.data.table(id_raster, xy = TRUE) |> na.omit()

  # Build prediction mesh
  mesh <- INLA::inla.mesh.2d(
    loc.domain = id_raster_table[, .(x, y)],
    max.edge = c(0.3, 5),
    cutoff = 0.05
  )
  # The maximum mesh dimension will be used to determine the SPDE range prior
  max_d <- apply(X = mesh$loc, MARGIN = 2, FUN = function(x) diff(range(x))) |>
    max(na.rm = T)

  # SPDE object
  spde <- INLA::inla.spde2.pcmatern(
    mesh = mesh,
    alpha = 2,
    constr = TRUE,
    prior.range = c(max_d * spde_range_pc_prior$threshold, spde_range_pc_prior$prob_below),
    prior.sigma = c(spde_sigma_pc_prior$threshold, spde_sigma_pc_prior$prob_above)
  )

  # Spatial index
  index_space <- INLA::inla.spde.make.index(name = "space", n.spde = spde$n.spde)

  # Projection matrix: mesh to data
  A_proj_data <- INLA::inla.spde.make.A(
    mesh = mesh,
    loc = as.matrix(input_data[, .(x, y)])
  )

  # Extract all covariates
  cov_names <- names(covariates)
  for(cov_name in cov_names){
    input_data[[cov_name]] <- terra::extract(
      x = covariates[[cov_name]],
      y = as.matrix(input_data[, .(x, y)])
    )[, 1]
  }

  # Data stack for estimation
  inla_data_stack <- INLA::inla.stack(
    tag = 'est',
    data = list(y = input_data$indicator, samplesize = input_data$samplesize),
    A = list(covariates = as.matrix(input_data[, ..cov_names]), s = A_proj_data),
    effects = list(covariates = seq_along(cov_names), s = index_space)
  )

  # INLA model formula
  if(sum_to_one){
    constraint_suffix <- glue::glue(
      ", extraconstr = list(A = matrix(1, ncol = {length(cov_names)}), e = 1)"
    )
  } else {
    constraint_suffix <- ""
  }
  formula_string <- glue::glue(
    "y ~ 0 + f(covariates, model = 'iid', fixed = TRUE {constraint_suffix}) + ",
    "f(space, model = spde)"
  )

  data_list <- list(
    mesh = mesh,
    spde = spde,
    inla_data_stack = inla_data_stack,
    formula_string = formula_string
  )

  return(data_list)
}
